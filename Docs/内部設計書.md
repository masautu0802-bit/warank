# 内部設計書

## 2. コンポーネント設計

### 2.1 Next.js App Router構造

```
app/
├── layout.tsx (Server Component)
│   └── Providers (Client Component)
│       ├── ThemeProvider
│       ├── AuthProvider
│       ├── DateProvider
│       ├── BalanceProvider
│       └── PredictionProvider
├── page.tsx (Server Component - ホーム)
├── comedian/
│   └── [id]/
│       └── page.tsx (Server Component)
├── event/
│   └── [id]/
│       └── page.tsx (Server Component)
└── predictions/
    └── page.tsx (Server Component)

components/
├── ui/ (shadcn/uiコンポーネント)
├── features/ (機能別コンポーネント - Client Components)
│   ├── comedian/
│   │   ├── ComedianCard.tsx ('use client')
│   │   └── ComedianDetail.tsx ('use client')
│   └── event/
│       ├── EventCard.tsx ('use client')
│       └── EventList.tsx ('use client')
├── layout/ (レイアウトコンポーネント)
│   ├── Header.tsx ('use client' - インタラクティブ)
│   └── Footer.tsx
└── animations/ (アニメーションコンポーネント)
    └── FadeIn.tsx ('use client')
```

### 2.2 コンポーネント分類

#### 2.2.1 サーバーコンポーネント
- `app/**/page.tsx`: ページコンポーネント
- `app/**/layout.tsx`: レイアウトコンポーネント
- データフェッチングを行うコンポーネント

#### 2.2.2 クライアントコンポーネント
- インタラクティブな機能（クリック、入力など）
- アニメーションが必要なコンポーネント
- ブラウザAPIを使用するコンポーネント
- 状態管理（useState, useEffectなど）が必要なコンポーネント

### 2.2 主要コンポーネントの詳細

#### 2.2.3 app/page.tsx (ホームページ - Server Component)

**責務**:
- データ取得（Server Component）
- ページレイアウトの構築

**主要ロジック**:
```typescript
import { createClient } from '@/lib/supabase/server';
import { HomePageClient } from '@/components/features/home/HomePageClient';

export default async function HomePage() {
  const supabase = createClient();
  
  // データ取得（Server Component）
  const [comediansResult, eventsResult, performancesResult] = await Promise.all([
    supabase.from('comedians').select('*'),
    supabase.from('events').select('*').order('date', { ascending: true }),
    supabase.from('performances').select('*'),
  ]);

  // ポイント計算（Server Component）
  const appData = calculateAppData({
    comedians: comediansResult.data || [],
    events: eventsResult.data || [],
    performances: performancesResult.data || [],
  });

  return <HomePageClient initialData={appData} />;
}
```

#### 2.2.4 components/features/home/HomePageClient.tsx (Client Component)

**責務**:
- 日付選択UIの表示
- イベント一覧の表示
- フィルタリング機能
- ランキングサイドバーの表示
- アニメーション処理

**主要状態**:
```typescript
'use client';

import { useState, useMemo } from 'react';
import anime from 'animejs';
import { useEffect, useRef } from 'react';

export function HomePageClient({ initialData }: { initialData: AppData }) {
  const [selectedDate, setSelectedDate] = useState<string>();
  const [maxTier, setMaxTier] = useState<EventTier>('E');
  const [showOnlyMajor4Brands, setShowOnlyMajor4Brands] = useState(false);
  const eventListRef = useRef<HTMLDivElement>(null);

  // 日付フィルタリング
  const filteredEvents = useMemo(() => {
    return events.filter(event => {
      // 日付マッチングロジック
      // ティアフィルタリング
      // 主要4大会フィルタリング
    });
  }, [selectedDate, maxTier, showOnlyMajor4Brands]);

  // アニメーション（useEffectで安全に実行）
  useEffect(() => {
    if (eventListRef.current) {
      anime({
        targets: eventListRef.current.children,
        opacity: [0, 1],
        translateY: [20, 0],
        delay: anime.stagger(50),
        duration: 500,
        easing: 'easeOutQuad',
      });
    }
  }, [filteredEvents]);

  return (
    <div>
      <DateSlider selectedDate={selectedDate} onDateChange={setSelectedDate} />
      <div ref={eventListRef}>
        {filteredEvents.map(event => (
          <EventCard key={event.id} event={event} />
        ))}
      </div>
      <RankingSidebar rankings={rankings} />
    </div>
  );
}
```

#### 2.2.5 app/comedian/[id]/page.tsx (Server Component)

**責務**:
- 日付選択UIの表示
- イベント一覧の表示
- フィルタリング機能
- ランキングサイドバーの表示

**主要状態**:
```typescript
const [selectedDate, setSelectedDate] = useState<string>();
const [maxTier, setMaxTier] = useState<EventTier>('E');
const [showOnlyMajor4Brands, setShowOnlyMajor4Brands] = useState(false);
```

**主要ロジック**:
```typescript
// 日付フィルタリング
const filteredEvents = useMemo(() => {
  return events.filter(event => {
    // 日付マッチングロジック
    // ティアフィルタリング
    // 主要4大会フィルタリング
  });
}, [selectedDate, maxTier, showOnlyMajor4Brands]);
```

**責務**:
- 芸人データの取得（Server Component）
- 芸人詳細ページのレンダリング

**主要ロジック**:
```typescript
import { createClient } from '@/lib/supabase/server';
import { notFound } from 'next/navigation';
import { ComedianDetailClient } from '@/components/features/comedian/ComedianDetailClient';

export default async function ComedianPage({
  params,
}: {
  params: { id: string };
}) {
  const supabase = createClient();
  const { data: comedian } = await supabase
    .from('comedians')
    .select('*')
    .eq('id', params.id)
    .single();

  if (!comedian) {
    notFound();
  }

  // 関連データ取得
  const { data: performances } = await supabase
    .from('performances')
    .select('*, events(*)')
    .eq('comedian_id', params.id);

  return (
    <ComedianDetailClient 
      comedian={comedian} 
      performances={performances || []} 
    />
  );
}
```

#### 2.2.6 components/features/comedian/ComedianDetailClient.tsx (Client Component)

**責務**:
- 芸人プロフィールの表示
- タブ切り替え機能
- パフォーマンス履歴の表示
- ランキング推移グラフの表示
- アニメーション処理

**主要状態**:
```typescript
'use client';

import { useState, useMemo, useEffect, useRef } from 'react';
import anime from 'animejs';

export function ComedianDetailClient({ 
  comedian, 
  performances 
}: { 
  comedian: Comedian;
  performances: Performance[];
}) {
  const [activeTab, setActiveTab] = useState<'metrics' | 'achievements' | 'upcoming' | 'analysis'>('metrics');
  const tabContentRef = useRef<HTMLDivElement>(null);

  // パフォーマンス履歴の計算
  const pastPerformances = useMemo(() => {
    return performances
      .filter(p => p.comedianId === comedian.id)
      .map(p => {
        const points = calculatePerformancePoints(p.rank, p.event);
        return { ...p, event: p.event, points };
      })
      .sort((a, b) => new Date(b.event.date).getTime() - new Date(a.event.date).getTime());
  }, [comedian, performances]);

  // タブ切り替え時のアニメーション
  useEffect(() => {
    if (tabContentRef.current) {
      anime({
        targets: tabContentRef.current,
        opacity: [0, 1],
        translateY: [10, 0],
        duration: 300,
        easing: 'easeOutQuad',
      });
    }
  }, [activeTab]);

  return (
    <div>
      <ComedianProfileHeader comedian={comedian} />
      <TabNavigation activeTab={activeTab} onTabChange={setActiveTab} />
      <div ref={tabContentRef}>
        {/* タブコンテンツ */}
      </div>
    </div>
  );
}
```

#### 2.2.7 app/event/[id]/page.tsx (Server Component)

**責務**:
- イベントデータの取得（Server Component）
- イベント詳細ページのレンダリング

#### 2.2.8 components/features/event/EventDetailClient.tsx (Client Component)

**責務**:
- イベント詳細情報の表示
- 参加芸人一覧の表示
- 予想機能の統合
- タブ切り替え機能
- アニメーション処理

**主要状態**:
```typescript
'use client';

const [activeTab, setActiveTab] = useState<'overview' | 'performers' | 'prediction'>('overview');
```

#### 2.2.9 app/predictions/page.tsx (Server Component)

**責務**:
- 予想可能なイベントの一覧表示
- ブランドごとのグループ化
- 予想状況の表示

**責務**:
- 予想可能なイベントの取得（Server Component）
- 予想一覧ページのレンダリング

**主要ロジック**:
```typescript
import { createClient } from '@/lib/supabase/server';
import { PredictionsPageClient } from '@/components/features/predictions/PredictionsPageClient';

export default async function PredictionsPage() {
  const supabase = createClient();
  
  const { data: events } = await supabase
    .from('events')
    .select('*')
    .in('brand', ['M-1', 'R-1', 'THE SECOND', 'キングオブコント']);

  return <PredictionsPageClient events={events || []} />;
}
```

#### 2.2.10 components/features/predictions/PredictionsPageClient.tsx (Client Component)

**責務**:
- 予想可能なイベントの一覧表示
- ブランドごとのグループ化
- 予想状況の表示
- アニメーション処理

**主要ロジック**:
```typescript
'use client';

import { useMemo, useEffect, useRef } from 'react';
import anime from 'animejs';

export function PredictionsPageClient({ events }: { events: Event[] }) {
  const eventGridRef = useRef<HTMLDivElement>(null);

  // ブランドごとのグループ化
  const eventsByBrand = useMemo(() => {
    const filtered = events.filter(event => 
      isPredictableEvent(event.brand, event.formatType)
    );
    
    const grouped: Record<string, Event[]> = {};
    filtered.forEach(event => {
      const brand = getBrandId(event) || 'other';
      if (!grouped[brand]) grouped[brand] = [];
      grouped[brand].push(event);
    });
    
    return grouped;
  }, [events]);

  // アニメーション
  useEffect(() => {
    if (eventGridRef.current) {
      anime({
        targets: eventGridRef.current.children,
        opacity: [0, 1],
        scale: [0.95, 1],
        delay: anime.stagger(100),
        duration: 400,
        easing: 'easeOutQuad',
      });
    }
  }, [eventsByBrand]);

  return (
    <div ref={eventGridRef}>
      {/* ブランドごとのイベントカード */}
    </div>
  );
}
```

## 3. 状態管理設計

### 3.1 Context APIによる状態管理

#### 3.1.1 AuthContext

**状態**:
```typescript
interface AuthContextType {
  user: User | null;
  session: Session | null;
  loading: boolean;
  signUp: (email: string, password: string) => Promise<{ error: AuthError | null }>;
  signIn: (email: string, password: string) => Promise<{ error: AuthError | null }>;
  signOut: () => Promise<void>;
  resetPassword: (email: string) => Promise<{ error: AuthError | null }>;
}
```

**実装**:
- Supabase Authの状態を監視
- 認証状態の変更を自動反映
- 認証メソッドの提供

#### 3.1.2 PredictionContext

**状態**:
```typescript
interface PredictionContextType {
  predictions: Record<string, EventPrediction>;
  loading: boolean;
  getPrediction: (eventId: string) => EventPrediction | null;
  savePrediction: (eventId: string, predictionEntries: PredictionEntry[]) => Promise<void>;
  clearPrediction: (eventId: string) => Promise<void>;
  hasPrediction: (eventId: string) => boolean;
  markAsPaidOut: (eventId: string) => Promise<void>;
}
```

**実装**:
- ユーザーの予想データを管理
- Supabaseとの同期
- ローカル状態とデータベースの同期

#### 3.1.3 BalanceContext

**状態**:
```typescript
interface BalanceContextType {
  balance: number;
  loading: boolean;
  updateBalance: (newBalance: number) => Promise<void>;
  addBalance: (amount: number) => Promise<void>;
  subtractBalance: (amount: number) => Promise<void>;
}
```

**実装**:
- ユーザーのポイント残高を管理
- ポイントの増減処理
- データベースとの同期

#### 3.1.4 DateContext

**状態**:
```typescript
interface DateContextType {
  selectedDate: string;
  baseDate: string;
  setSelectedDate: (date: string) => void;
  setBaseDate: (date: string) => void;
  handleDateChange: (date: string) => void;
}
```

**実装**:
- 選択された日付の管理
- URLパラメータとの同期

#### 3.1.5 ThemeContext

**状態**:
```typescript
interface ThemeContextType {
  theme: 'light' | 'dark';
  toggleTheme: () => void;
}
```

**実装**:
- テーマの切り替え
- ユーザー設定の保存

### 3.2 ローカル状態管理

**useState**:
- コンポーネント固有の状態
- フォーム入力値
- UI状態（モーダル開閉など）

**useMemo**:
- 計算結果のメモ化
- フィルタリング結果
- ソート結果

**useCallback**:
- 関数のメモ化
- イベントハンドラー
- コールバック関数

## 4. ビジネスロジック設計

### 4.1 ポイント計算ロジック

#### 4.1.1 基本ポイント計算

**ファイル**: `utils/CalculatePoints.ts`

**関数**: `calculatePerformancePoints`

**ロジック**:
```typescript
function calculatePerformancePoints(
  rank: number | null,
  event: EventData,
  options?: {
    comedianId?: string;
    performances?: Performance[];
    events?: Record<string, EventData>;
  }
): PerformancePoints {
  // 1. 順位が確定している場合
  if (rank !== null) {
    // ノミネート方式の特別処理
    if (event.formatType === 'nomination-selection') {
      // 最終ラウンドで1位以外は進出ポイント
      // 1位は通常ポイント
    }
    // 通常のポイント計算
    const basePoints = getBasePoints(event.tier, rank);
    return {
      basePoints,
      multiplier: event.multiplier,
      earnedPoints: Math.round(basePoints * event.multiplier)
    };
  }
  
  // 2. 順位がnullの場合（勝ち抜けポイント）
  if (event.seriesId && options) {
    // 次のラウンドに進出しているかチェック
    // 進出ポイントを計算
    // それ以降のラウンドの最低獲得ポイントを考慮
  }
  
  return { basePoints: 0, multiplier: event.multiplier, earnedPoints: 0 };
}
```

#### 4.1.2 総ポイント計算

**関数**: `calculateComedianTotalPoints`

**ロジック**:
```typescript
function calculateComedianTotalPoints(
  comedianId: string,
  performances: Performance[],
  events: Record<string, EventData>
): number {
  // 1. この芸人の全てのパフォーマンスを取得
  const comedianPerformances = performances.filter(
    p => p.comedianId === comedianId
  );
  
  // 2. シリーズごとにグループ化
  const seriesMap = new Map();
  
  comedianPerformances.forEach(performance => {
    const event = events[performance.eventId];
    if (!event || !isEventPast(event)) return;
    
    // 3. ポイントを計算
    const points = calculatePerformancePoints(performance.rank, event, {
      comedianId,
      performances,
      events
    }).earnedPoints;
    
    // 4. シリーズ内では最も後のラウンドのみを選択
    if (event.seriesId) {
      const roundOrder = event.roundOrder ?? 0;
      const existing = seriesMap.get(event.seriesId);
      if (!existing || roundOrder > existing.roundOrder) {
        seriesMap.set(event.seriesId, { roundOrder, points });
      }
    } else {
      seriesMap.set(`no-series-${performance.eventId}`, { roundOrder: 0, points });
    }
  });
  
  // 5. ポイントを合計
  let total = 0;
  seriesMap.forEach(({ points }) => {
    total += points;
  });
  
  return total;
}
```

### 4.2 属性値計算ロジック

**ファイル**: `utils/CalculateAttributes.ts`

**関数**: `calculateAllAttributes`

**ロジック**:
```typescript
function calculateAllAttributes(data: AppData): Record<string, AttributeStats> {
  const attributes: Record<string, AttributeStats> = {};
  
  Object.values(data.comedians).forEach(comedian => {
    // Power: 総合力（偏差値計算）
    // Clutch: 決勝力（偏差値計算）
    // Champion: 頂点到達力（偏差値計算）
    // Stability: 安定感（偏差値計算）
    // Experience: 経験値（偏差値計算）
    
    attributes[comedian.id] = {
      power: calculatePower(comedian, data),
      clutch: calculateClutch(comedian, data),
      champion: calculateChampion(comedian, data),
      stability: calculateStability(comedian, data),
      experience: calculateExperience(comedian, data)
    };
  });
  
  return attributes;
}
```

### 4.3 予想ロジック

#### 4.3.1 オッズ計算

**ファイル**: `utils/oddsCalculator.ts`

**関数**: `calculateOdds`

**ロジック**:
```typescript
function calculateOdds(
  comedianId: string,
  eventId: string,
  predictionType: PredictionType,
  data: AppData
): number {
  // 1. 芸人の人気度を計算（総ポイントベース）
  const comedian = data.comedians[comedianId];
  const totalPoints = comedian.totalPoints;
  
  // 2. イベント参加芸人の平均ポイントを計算
  const eventPerformances = data.performances.filter(p => p.eventId === eventId);
  const averagePoints = eventPerformances.reduce((sum, p) => {
    return sum + (data.comedians[p.comedianId]?.totalPoints || 0);
  }, 0) / eventPerformances.length;
  
  // 3. オッズを計算（人気度に反比例）
  const popularityRatio = totalPoints / averagePoints;
  const baseOdds = 1 / popularityRatio;
  
  // 4. 予想形式による調整
  const typeMultiplier = getTypeMultiplier(predictionType);
  
  return baseOdds * typeMultiplier;
}
```

#### 4.3.2 的中判定

**ファイル**: `utils/predictionUtils.ts`

**関数**: `calculateAllPredictionResults`

**ロジック**:
```typescript
function calculateAllPredictionResults(
  prediction: EventPrediction,
  data: AppData
): PredictionResult[] {
  const results: PredictionResult[] = [];
  const event = data.events[prediction.eventId];
  const actualPerformances = data.performances
    .filter(p => p.eventId === prediction.eventId)
    .sort((a, b) => (a.rank || 999) - (b.rank || 999));
  
  prediction.predictions.forEach(entry => {
    const isWon = checkPredictionWin(entry, actualPerformances, data);
    const odds = entry.odds || 1;
    const payout = isWon ? entry.betPoints * odds : 0;
    const profit = payout - entry.betPoints;
    
    results.push({
      eventId: prediction.eventId,
      eventName: event.name,
      predictionType: entry.predictionType,
      isWon,
      betPoints: entry.betPoints,
      odds,
      payout,
      profit,
      details: getPredictionDetails(entry, actualPerformances, data),
      predictedComedianNames: entry.predictedComedianIds.map(id => data.comedians[id]?.name || ''),
      actualComedianNames: getActualComedianNames(entry.predictionType, actualPerformances, data),
      createdAt: prediction.createdAt
    });
  });
  
  return results;
}
```

## 5. データフロー設計

### 5.1 データ取得フロー（Next.js App Router）

```
app/page.tsx (Server Component)
  └─> Promise.all([
      ├─> supabase.from('comedians').select('*')
      ├─> supabase.from('events').select('*')
      └─> supabase.from('performances').select('*')
    ])
  └─> calculateAppData() (Server Component)
  └─> HomePageClient (Client Component)
      └─> インタラクティブな機能とアニメーション
```

### 5.2 アニメーションフロー

```
Client Component
  └─> useEffect(() => {
      └─> anime({
          targets: ref.current,
          opacity: [0, 1],
          translateY: [20, 0],
          // transformとopacityを中心に使用
        })
    }, [dependencies])
```

**ベストプラクティス**:
- Reactのステートは`useState`で管理
- CSSクラスは`className`で管理
- anime.jsは`transform`と`opacity`のみを操作
- DOM操作は`useEffect`内で安全に実行

### 5.3 ポイント計算フロー

```
app/page.tsx (Server Component)
  └─> calculateAppData() (Server Component)
      ├─> calculateComedianTotalPoints()
      │   └─> calculatePerformancePoints()
      │       └─> getBasePoints()
      ├─> ランク付け
      ├─> 履歴計算
      └─> calculateAllAttributes()
          └─> 各属性値の計算
  └─> HomePageClient (Client Component)
      └─> 計算結果をpropsで受け取り
```

### 5.4 予想保存フロー

```
components/features/prediction/PredictionInput.tsx (Client Component)
  └─> savePrediction()
      └─> PredictionContext.savePrediction()
          ├─> ローカル状態更新（useState）
          └─> saveToDatabase()
              └─> supabase.from('event_predictions').upsert()
                  └─> API RouteまたはServer Action
```

## 6. エラーハンドリング設計

### 6.1 エラーハンドリング戦略

**データ取得エラー**:
```typescript
try {
  const data = await fetchAllData();
  setDbData(data);
} catch (error) {
  console.error('データ取得エラー:', error);
  setError('データの取得に失敗しました。ページを再読み込みしてください。');
}
```

**認証エラー**:
```typescript
const { error } = await supabase.auth.signInWithPassword({
  email,
  password
});
if (error) {
  // エラーメッセージを表示
  setAuthError(error.message);
}
```

**予想保存エラー**:
```typescript
try {
  await saveToDatabase(eventId, prediction);
} catch (error) {
  console.error('予想データの保存に失敗しました:', error);
  // エラーメッセージを表示
  // ローカル状態をロールバック
}
```

### 6.2 フォールバック機能

**データ取得失敗時**:
- エラーメッセージの表示
- リトライボタンの提供
- モックデータへのフォールバック（開発時のみ）

## 7. パフォーマンス最適化設計

### 7.1 メモ化戦略

**useMemo**:
- 計算結果のメモ化
- フィルタリング結果のメモ化
- ソート結果のメモ化

**useCallback**:
- イベントハンドラーのメモ化
- コールバック関数のメモ化

### 7.2 レンダリング最適化

**コンポーネント分割**:
- 大きなコンポーネントを小さく分割
- 再レンダリングの範囲を限定

**条件付きレンダリング**:
- 不要なレンダリングを避ける
- 早期リターンの活用

### 7.3 データ取得最適化

**並列取得**:
```typescript
const [comediansResult, eventsResult, performancesResult] = await Promise.all([
  fetchComedians(),
  fetchEvents(),
  fetchPerformances()
]);
```

**キャッシュ**:
- ブラウザキャッシュの活用
- データの再取得タイミングの最適化

## 8. テスト設計

### 8.1 テスト方針

**単体テスト**:
- ユーティリティ関数のテスト
- ポイント計算ロジックのテスト
- 属性値計算ロジックのテスト

**統合テスト**:
- コンポーネントの統合テスト
- API連携のテスト

**E2Eテスト**:
- 主要フローのテスト
- ユーザー操作のテスト

### 8.2 テスト対象

**ビジネスロジック**:
- `calculatePerformancePoints`
- `calculateComedianTotalPoints`
- `calculateAllAttributes`
- `calculateAllPredictionResults`

**ユーティリティ**:
- `getBasePoints`
- `getAdvancementBasePoints`
- `isPointsExcludedBySeries`

## 9. デプロイ設計

### 9.1 ビルド設定

**Next.js設定**:
```typescript
// next.config.ts
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
```

**環境変数**:
- `.env.local`: 開発環境（.gitignoreに追加）
- `.env.production`: 本番環境
- `NEXT_PUBLIC_*`: クライアントサイドで使用可能
- それ以外: サーバーサイドのみ

### 9.2 デプロイフロー

1. コードのビルド: `npm run build`
2. 静的ファイルとサーバーサイドコードの生成: `.next/`ディレクトリ
3. デプロイ先へのアップロード（Vercel推奨）
4. 環境変数の設定

## 10. 保守性設計

### 10.1 コード規約

**命名規則**:
- コンポーネント: PascalCase
- 関数・変数: camelCase
- 定数: UPPER_SNAKE_CASE
- 型・インターフェース: PascalCase

**ファイル構成**:
- 1コンポーネント = 1ファイル
- 関連する機能は同じディレクトリに配置
- `app/`: ページとレイアウト（Server Components）
- `components/`: 再利用可能なコンポーネント（Client Components）

### 10.2 アニメーション実装規約

**anime.js使用ルール**:
```typescript
'use client';

import { useEffect, useRef } from 'react';
import anime from 'animejs';

export function AnimatedComponent() {
  const ref = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (ref.current) {
      anime({
        targets: ref.current,
        opacity: [0, 1],        // opacityを中心に
        translateY: [20, 0],     // transformを中心に
        duration: 500,
        easing: 'easeOutQuad',   // 上品で軽い動き
      });
    }
  }, []);

  return <div ref={ref}>Content</div>;
}
```

**禁止事項**:
- ❌ Reactのステートをanime.jsで直接変更
- ❌ CSSクラスをanime.jsで直接変更
- ✅ transformとopacityのみを使用
- ✅ useEffect内で安全に実行

### 10.2 ドキュメント

**コメント**:
- 複雑なロジックにはコメントを追加
- JSDocコメントの活用

**型定義**:
- TypeScriptによる型安全性の確保
- インターフェースの明確な定義
